import { ColumnSlug, Integer, Time, Color, CoreValueType } from "./CoreTableConstants";
import { CoreTable } from "./CoreTable";
import { EntityName, OwidColumnDef, OwidRow } from "./OwidTableConstants";
import { TimeBound } from "../clientUtils/TimeBounds";
import { CoreColumn } from "./CoreTableColumns";
export declare class OwidTable extends CoreTable<OwidRow, OwidColumnDef> {
    entityType: string;
    get availableEntityNames(): any[];
    get availableEntityNameSet(): Set<string>;
    get entityIdToNameMap(): Map<number, string>;
    get entityCodeToNameMap(): Map<string, string>;
    get entityNameToIdMap(): Map<string, number>;
    get entityNameToCodeMap(): Map<string, string>;
    get maxTime(): number | undefined;
    get entityIdColumn(): CoreColumn;
    get entityCodeColumn(): CoreColumn;
    get minTime(): Time;
    private get allTimes();
    get rowIndicesByEntityName(): Map<string, number[]>;
    getAnnotationColumnSlug(columnDef: OwidColumnDef): string | undefined;
    getAnnotationColumnForColumn(columnSlug: ColumnSlug): CoreColumn;
    getTimesUniqSortedAscForColumns(columnSlugs: ColumnSlug[]): number[];
    timeDomainFor(slugs: ColumnSlug[]): [Time | undefined, Time | undefined];
    originalTimeDomainFor(slugs: ColumnSlug[]): [Time | undefined, Time | undefined];
    filterByEntityNames(names: EntityName[]): this;
    private get sortedByTime();
    filterByTimeRange(start: TimeBound, end: TimeBound): this;
    filterByTargetTimes(targetTimes: Time[], tolerance?: number): this;
    dropRowsWithErrorValuesForColumn(slug: ColumnSlug): this;
    dropRowsWithErrorValuesForAnyColumn(slugs: ColumnSlug[]): this;
    dropRowsWithErrorValuesForAllColumns(slugs: ColumnSlug[]): this;
    private sumsByTime;
    toPercentageFromEachEntityForEachTime(columnSlug: ColumnSlug): this;
    toPercentageFromEachColumnForEachEntityAndTime(columnSlugs: ColumnSlug[]): this;
    toTotalGrowthForEachColumnComparedToStartTime(startTimeBound: TimeBound, columnSlugs: ColumnSlug[]): this;
    keepMinTimeAndMaxTimeForEachEntityOnly(): this;
    private getAverageAnnualChangeIndicesByEntity;
    toAverageAnnualChangeForEachEntity(columnSlugs: ColumnSlug[]): this;
    get suggestedYColumnSlugs(): string[];
    toPrettyCsv(): string;
    get entityNameColorIndex(): Map<EntityName, Color>;
    getColorForEntityName(entityName: EntityName): Color | undefined;
    get columnDisplayNameToColorMap(): Map<string, Color>;
    getColorForColumnByDisplayName(displayName: string): string | undefined;
    getLatestValueForEntity(entityName: EntityName, columnSlug: ColumnSlug): CoreValueType | undefined;
    entitiesWith(columnSlugs: ColumnSlug[]): Set<EntityName>;
    private interpolate;
    interpolateColumnWithTolerance(columnSlug: ColumnSlug, toleranceOverride?: number): this;
    interpolateColumnLinearly(columnSlug: ColumnSlug, extrapolate?: boolean): this;
    interpolateColumnsByClosestTimeMatch(columnSlugA: ColumnSlug, columnSlugB: ColumnSlug): this;
    getClosestIndexForEachEntity(entityNames: EntityName[], targetTime: Time, tolerance: Integer): number[];
    filterByPopulationExcept(minPop: number, entityNames?: string[]): this;
    get availableEntities(): {
        entityName: any;
        entityId: number | undefined;
        entityCode: string | undefined;
    }[];
    sampleEntityName(howMany?: number): any[];
    get isBlank(): boolean;
}
export declare const BlankOwidTable: (tableSlug?: string, extraTableDescription?: string) => OwidTable;
//# sourceMappingURL=OwidTable.d.ts.map